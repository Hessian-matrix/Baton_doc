# 串口通信

UART的接口为GH1.0的5pin，从螺丝孔那里开始从左到右分别是GND、TRIG、TX、RX、5V。

![](image/image_YcAJ7_52sA.png)

如果是单纯串口通信的话就是接GND、TX、RX即可，需要注意的是串口电平是3.3V的如果接了5V会把串口烧掉。

## 一.数据协议

### 1.系统控制帧

| 帧头        | 控制位         | 保留位    | 和校验位                               | 帧尾        |
| --------- | ----------- | ------ | ---------------------------------- | --------- |
| 0x67 0x28 | 控制系统运行状态的指令 |        | 累加和（\\\<mark>不包含帧头帧尾校验位\\\</mark>） | 0x09 0x0d |
| 2byte     | 1byte       | 28byte | 1byte                              | 2byte     |

**控制位：**

- 0x01 启动算法程序
- 0x02 停止算法程序
- 0x03 重启算法程序

**校验和：** 计算校验和时从帧头开始计算，一直累加到保留位的最后一位为止，一共要计算29bit

```c++
char check = 0;

for(int i = 2;i < 31;i++){

    check += receiveBuffer[i];

}
```

## 2.姿态输出帧

单帧共57byte

| 帧头      | frame_id | pose                                    | 四元数                           | 加速度                           | 角速度                           | 校验和                                               | 帧尾      |
| --------- | :------: | --------------------------------------- | -------------------------------- | -------------------------------- | -------------------------------- | ---------------------------------------------------- | --------- |
| 0x66 0x27 |   int    | pose的x、y、z三维坐标输出，每个分量4bit | x、y、z、w四个分量，每个分量4bit | lx、ly、lz三个分量，每个分量4bit | ax、ay、az三个分量，每个分量4bit | 数据部分（不包含帧头帧尾校验位部分）的所有数据累加和 | 0x08 0x0a |
| 2byte     |  4byte   | 12byte                                  | 16byte                           | 12byte                           | 12byte                           | 1byte                                                | 2byte     |

**数据位：** 数据位传输的是结构体通过内存拷贝到char数组上的方式传输，实际上就是float型数据在内存中存放的数据位，同理解析时也是通过memcpy进行内存拷贝解码。

**校验和：** 计算校验和的方式和系统控制帧的计算方式相同。

数据位的结构体示例：

```c++
struct pose_t{
    float px,py,pz,qx,qy,qz,qw;    //pose 和 四元素
};
struct speed_t{
    float lx,ly,lz,ax,ay,az;      //线性加速度 和 角速度
};
```

## 二.示例代码

下面通过一个简单的程序实现以下功能：

1. 发送启动指令启动算法；
2. 接受算法通过串口传输的位姿。

```c++
#include <stdio.h>
#include <cstring>
#include <cstdint>
#include <iostream>
#include <unistd.h>
#include <serial/serial.h>
#include <ros/ros.h>
//demo 程序
//功能： 1) 发送状态控制指令到Mini控制启停算法等
//       2)解码Mini发送的姿态数据

#define LREV_LEN    61
#define LSEND_LEN   34
#define LS_CHECK    LSEND_LEN - 3   //发送校验位序列
#define LR_CHECK    LREV_LEN - 3    //接收校验位置
#define SHEAD_1     0x67    //发送帧头
#define SHEAD_2     0X28
#define STILE_1     0X09
#define STILE_2     0X0d

#define RHEAD_1     0X66    //接收帧头
#define RHEAD_2     0X27
#define RTILE_1     0X08
#define RTILE_2     0X0a   
#define N           64

serial::Serial serial_port;

uint8_t receive_buffer[N];
uint8_t send_buffer[N];
enum sys_state{
    Ksys_on = 0x01,     //启动
    Ksys_off = 0x02,    //停止
    Ksys_restart = 0x03,    //重置
    Ksys_none   = 0x00,
};

struct pose_t{
    float px,py,pz,qx,qy,qz,qw;
};
struct speed_t
{
    float lx,ly,lz,ax,ay,az;
};
/// @brief command 数据包初始化
void pack_init()
{
    send_buffer[0] = RHEAD_1;
    send_buffer[1] = RHEAD_2;
    send_buffer[LREV_LEN-2] = RTILE_1;
    send_buffer[LREV_LEN-1] = RTILE_2;
}

/// @brief 解析数据包
/// @param pose_out [out] 
/// @param speed_out [out]
void unpack_uart(pose_t& pose_out,speed_t& speed_out)
{
    std::cout<<"receive:"<<std::endl;
    for(int i=0;i<LREV_LEN;i++)  
    {
        printf("%x ",receive_buffer[i]);
    }std::cout<<std::endl;

    if(receive_buffer[0]==RHEAD_1 && receive_buffer[1]==RHEAD_2 && receive_buffer[LREV_LEN - 2]==RTILE_1 && receive_buffer[LREV_LEN - 1]==RTILE_2 )
    {
        char check=0;
        //61-3
        for(int i=2;i<LR_CHECK;i++)
        {
            check+=receive_buffer[i];
        }
        if(check==receive_buffer[LR_CHECK])
        {
           	int frame_id = 0;
            std::cout<<"\n========pack ok"<<std::endl;
            memcpy(&frame_id,receive_buffer + 2,sizeof(frame_id));
            memcpy(&pose_out,receive_buffer + 2 + 4,sizeof(pose_out));
            memcpy(&speed_out,receive_buffer + 2 + 4 + sizeof(pose_out),sizeof(speed_out));
            //px,py,pz,qx,qy,qz,qw;
            printf("pose [%f,%f,%f,%f,%f,%f,%f]\n",pose_out.px,pose_out.py,pose_out.pz,pose_out.qx,pose_out.qy,pose_out.qz,pose_out.qw);
            //lx,ly,lz,ax,ay,az;
            printf("speed [%f,%f,%f,%f,%f,%f]\n",speed_out.lx,speed_out.ly,speed_out.lz,speed_out.ax,speed_out.ay,speed_out.az);
        }
        else
        {
            std::cout<<"check err"<<std::endl;
            printf("want is %x,but receive:%x\n",check,receive_buffer[LR_CHECK]);
        }
    }
    else{
        std::cout<<"pack format err"<<std::endl;
    }

}

/// @brief 发送控制指令
/// @param t sys_state 控制指令
void send_commend(sys_state &t)
{   
    memset(send_buffer,0,LSEND_LEN);
    send_buffer[0] = SHEAD_1;
    send_buffer[1] = SHEAD_2;
    send_buffer[2] = t;
    char check_sum = 0;
    for(int i=2;i<LS_CHECK;i++)
    {
        check_sum += send_buffer[i];
    }
    send_buffer[LS_CHECK] = check_sum;
    send_buffer[LSEND_LEN - 2] = STILE_1;
    send_buffer[LSEND_LEN - 1 ] = STILE_2;
    serial_port.write(send_buffer,LSEND_LEN);    //已发送
    std::cout<<"send is"<<std::endl;
    for(int i=0;i<LSEND_LEN;i++)  
    {
        printf("%x ",send_buffer[i]);
    }
}

int main(int argc,char **argv)
{
    ros::init(argc,argv,"example_serial");
    ros::NodeHandle nh;
    std::string port_name="/dev/ttyUSB0";
    try{
        serial_port.setPort(port_name);
        serial_port.setBaudrate(115200);
        serial::Timeout timeout = serial::Timeout::simpleTimeout(1000);
        serial_port.setTimeout(timeout);
        serial_port.open();

    }catch(serial::IOException& e){
        std::cerr<<"can't open serial. "<<port_name<<std::endl;
        return 1;
    }
    if(!serial_port.isOpen()){
        std::cerr<<"serial is note opend"<<std::endl;
    }
    pose_t pose;
    speed_t speed;

    sys_state s=Ksys_on;
    pack_init();
    send_commend(s); //启动算法
    std::cout<<"send on\n";
    bool start_=false;
    uint8_t end_;
    uint8_t Max_count = LREV_LEN;
    while(ros::ok())
    {
        while(!start_ && Max_count--)
        {
            serial_port.read(&end_,1);
            if(end_ == RTILE_1)
            {
                serial_port.read(&end_,1);
                if(end_ == RTILE_2){
                    start_ = true;
                    break;
                } 
            }
        }
        serial_port.read(&receive_buffer[0],1);
        if(receive_buffer[0] == RHEAD_1){
            serial_port.read(receive_buffer+1,LREV_LEN - 1);
            unpack_uart(pose,speed);
            // sleep(1);
        }

    }
    s=Ksys_off;
    send_commend(s);       //停止算法
    std::cout<<"send system off"<<std::endl;
    serial_port.close();
    return 0;
}
```

此程序依赖于ros-serial库，可以通过apt安装或者下载ros serial的源码

sudo apt install  ros-noetic-serial

git clone [https://github.com/wjwwood/serial.git](https://github.com/wjwwood/serial.git "https://github.com/wjwwood/serial.git")
